#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import time
import re
from collections import defaultdict

import networkx as nx
import numpy as np
import rclpy
import rclpy.qos
import torch
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup
from rclpy.executors import MultiThreadedExecutor
from rclpy.node import Node
from std_msgs.msg import String, Float32

from ros2_dist_gnn_msgs.msg import Discovery
from ros2_dist_gnn.utils.led_matrix import LEDMatrix
from topocon_msgs.msg import ConsensusMessage

comm_qos = rclpy.qos.QoSProfile(
    history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,
    depth=10,
    reliability=rclpy.qos.QoSReliabilityPolicy.RELIABLE,
    durability=rclpy.qos.QoSDurabilityPolicy.TRANSIENT_LOCAL,
)

fresh_qos = rclpy.qos.QoSProfile(
    history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,
    depth=1,
    reliability=rclpy.qos.QoSReliabilityPolicy.BEST_EFFORT,
    durability=rclpy.qos.QoSDurabilityPolicy.TRANSIENT_LOCAL,
)


class MyNode(Node):

    def __init__(self):
        super().__init__('gnn_node')

        # Unique identifier for the node. # DOC: We assume all nodes have the same format of the name.
        self.node_name = self.get_namespace().strip("/")
        if self.node_name == '/':
            self.node_name = 'node_0'

        if not re.match(r'^[a-zA-Z_]+\d+$', self.node_name):
            self.get_logger().error(f"Node name should be in the format <string>_<integer. Got: {self.node_name}")
            raise ValueError(f"Invalid node name format: {self.node_name}")

        self.node_prefix = self.node_name.split("_")[0] + "_"
        self.node_id = int(self.node_name.split("_")[-1])
        self.get_logger().info(f'GNN Node {self.node_name} has been started.')

        # Load parameters
        self.declare_parameter("num_nodes", 1)
        self.declare_parameter("comm_radius", 2.0)
        self.declare_parameter('sigma', 0.25)   # Consensus step size for the average graph.
        self.declare_parameter('num_consensus_steps', 50)

        self.num_nodes = self.get_parameter("num_nodes").get_parameter_value().integer_value
        self.communication_radius = self.get_parameter("comm_radius").get_parameter_value().double_value
        self.sigma = self.get_parameter('sigma').get_parameter_value().double_value
        self.num_consensus_steps = self.get_parameter('num_consensus_steps').get_parameter_value().integer_value

        # Initialize variables
        self.value = np.zeros((self.num_nodes,self.num_nodes))  # The current representation of the node.
        self.received_msg = defaultdict(dict)  # Consensus values received from neighbors, indexed by iteration number.
                                               # Also used for synchronization.

        self.round_counter = 0
        self.local_subgraph = nx.Graph()
        self.latest_discovery_msg = Discovery()
        self.active_neighbors = []

        # Define callback groups. Using callback groups ensures the proper use of resources thanks to multi-threading.
        # All callbacks assigned to a MutuallyExclusiveCallbackGroup will be executed in the same thread, but in
        # parallel to callbacks in other callback groups.
        self.timer_cb_group = MutuallyExclusiveCallbackGroup()  # Main timer loop callback group.
        self.consensus_cb_group = MutuallyExclusiveCallbackGroup()  # Exclusively for message passing.
        self.pooling_cb_group = MutuallyExclusiveCallbackGroup()  # Exclusively for pooling.
        self.sub_cb_group = MutuallyExclusiveCallbackGroup()  # Exclusively for subscribing to other topics.

        # Create publishers for sending values to neighbors.
        self.consensus_pubs = {f"{self.node_prefix}{i}": self.create_publisher(ConsensusMessage, f"/{self.node_prefix}{i}/consensus", comm_qos) for i in range(self.num_nodes) if i != self.node_id}
        self.lambda_pub = self.create_publisher(Float32, "lambda2", fresh_qos)

        # Create subscribers for receiving values from neighbors and neighbor positions.
        self.consensus_sub = self.create_subscription(ConsensusMessage, "consensus", self.receive_consensus, comm_qos, callback_group=self.consensus_cb_group)

        # Subscriber for receiving the whole graph.
        #   This is used only in development to test the functionality using the
        #   predefined full graph generated by graph_generator.py without robot
        #   position data.
        self.declare_parameter("dev_mode", False)
        self.dev_mode = self.get_parameter("dev_mode").get_parameter_value().bool_value
        if self.dev_mode:
            self.graph_sub = self.create_subscription(String, '/graph_topic', self.graph_cb, fresh_qos, callback_group=self.sub_cb_group)
        else:
            self.discovery_sub = self.create_subscription(Discovery, 'discovery', self.discovery_cb, fresh_qos, callback_group=self.sub_cb_group)

        self.main_loop = self.create_timer(0.1, self.compute_topocon, callback_group=self.timer_cb_group)

        # Initialize the LED matrix if available.
        self.led = LEDMatrix()

        self.get_logger().debug("Node initialized.")

    def graph_cb(self, msg):
        G = nx.from_graph6_bytes(bytes(msg.data.strip(), "ascii"))
        lambda2 = nx.laplacian_spectrum(G)[1]
        self.get_logger().debug(f"Received graph {msg.data} with algebraic connectivity λ₂: {lambda2:.4f}")

        self.local_subgraph: nx.Graph = G.subgraph([self.node_id] + list(G.neighbors(self.node_id)))

    def discovery_cb(self, msg: Discovery):
        # DOC: Change how discovery messages are processed to build the local subgraph.
        self.latest_discovery_msg = msg

    def get_neighbors(self):
        self.active_neighbors = []

        if self.dev_mode:
            # We know the whole graph in development mode.
            if self.local_subgraph.number_of_nodes() > 0:
                self.active_neighbors = [f"{self.node_prefix}{i}" for i in self.local_subgraph.neighbors(self.node_id)]
        else:
            node_ids = [self.node_id] + list(map(int, self.latest_discovery_msg.neighbor_ids))
            node_pos = [self.latest_discovery_msg.own_position] + list(self.latest_discovery_msg.neighbor_positions)

            self.local_subgraph = nx.Graph()
            self.local_subgraph.add_nodes_from(node_ids)

            for i in range(len(node_ids)):
                for j in range(i + 1, len(node_ids)):
                    distance = ((node_pos[i].x - node_pos[j].x)**2 + (node_pos[i].y - node_pos[j].y)**2)**0.5
                    if distance <= self.communication_radius:
                        self.local_subgraph.add_edge(node_ids[i], node_ids[j])

            self.active_neighbors = [f"{self.node_prefix}{i}" for i in self.local_subgraph.neighbors(self.node_id)]

        assert nx.is_connected(self.local_subgraph), "Local subgraph is not connected! This should never happen."
        ready = len(self.active_neighbors) > 0

        if ready:
            self.get_logger().info(f"Active neighbors: {self.active_neighbors}")
        return ready

    def get_initial_features(self):
        G = nx.Graph()
        G.add_nodes_from(range(self.num_nodes))

        self.tau = np.zeros((self.num_nodes,))
        for i in self.local_subgraph.neighbors(self.node_id):
            G.add_edge(self.node_id, i)
            self.tau[int(i)] = 1.0

        return nx.to_numpy_array(G)

    def calc_update_diff(self, i, j, node_value, neighbor_values):
        if self.node_id == i:
            d = self.tau[j] - node_value[i, j]
        elif self.node_id == j:
            d = self.tau[i] - node_value[i, j]
        else:
            d = 0

        delta = 0
        for p, Ap in neighbor_values.items():
            delta += node_value[self.node_id, p] * (Ap[i, j] - node_value[i, j])

        return delta + d

    def calc_lambda_and_sigma(self, A):
        D = np.diag(np.sum(A, axis=1))
        L = D - A
        eigenvalues = np.linalg.eigvalsh(L)
        eigenvalues = np.sort(eigenvalues)
        lambda2 = eigenvalues[1]
        lambdaN = eigenvalues[-1]
        sigma = 2.0 / (2 + lambdaN)

        return lambda2, sigma

    def run_consensus(self, step, current_value: np.ndarray):
        # Send the current node representation to neighbors.
        self.send_consensus(step, current_value)

        # Wait until values are received from all neighbors.
        wait_time_start = time.time()
        while len(self.received_msg[step]) < len(self.active_neighbors):
            if time.time() - wait_time_start > 2.0:  # 2 seconds timeout
                self.get_logger().warn(f"Timeout waiting for messages at step {step}. Proceeding with available messages.")
                break
            self.get_logger().debug(f"Waiting for messages at step {step}...", throttle_duration_sec=1.0)
            time.sleep(0.01)

        # Update the node's representation using the GNN layer.
        new_value = current_value.copy()

        for i in range(self.num_nodes):
            for j in range(self.num_nodes):
                if i != j:
                    diff = self.calc_update_diff(i, j, current_value, self.received_msg[step])
                    new_value[i, j] = current_value[i, j] + self.sigma * diff

        self.get_logger().debug(f"Updated step {step}.")
        del self.received_msg[step]  # Clear messages for this step to free memory.

        return new_value

    def send_consensus(self, step: int, value: np.ndarray):
        msg = ConsensusMessage()
        msg.sender_id = self.node_id
        msg.step = step
        msg.data = value.flatten().tolist()  # Flatten tensor to 1D list
        msg.shape = list(value.shape)  # Store original shape

        for neighbor in self.active_neighbors:
            self.consensus_pubs[neighbor].publish(msg)
            self.get_logger().debug(f"Sent message to {neighbor} at step {step}")

    def receive_consensus(self, msg: ConsensusMessage):
        self.get_logger().debug(f"Received message from {msg.sender_id} at step {msg.step}")
        # Reconstruct tensor from flattened data and shape
        data = np.array(msg.data).reshape(tuple(msg.shape))
        self.received_msg[msg.step][msg.sender_id] = data

    def neighbor_position_cb(self, msg):
        pass

    def compute_topocon(self):
        ready = self.get_neighbors()
        if not ready:
            self.get_logger().info("Waiting for neighbors...", throttle_duration_sec=1.0)
            return

        self.round_counter += 1
        self.get_logger().info(f"Round {self.round_counter} started.")

        A0 = self.get_initial_features()
        if self.round_counter == 1:
            self.value = A0

        # Main topocon loop
        for k in range(self.num_consensus_steps):
            new_value = self.run_consensus(k, self.value)
            lambda2, self.sigma = self.calc_lambda_and_sigma(new_value)
            self.value = new_value.copy()

            self.lambda_pub.publish(Float32(data=lambda2))

            # Update LED color based on the estimated value.
            led_color = LEDMatrix.from_colormap(LEDMatrix.interp(lambda2, 0.0, self.num_nodes, 0.0, 1.0), color_space='hsv', cmap_name="jet")
            led_color = (led_color[0], led_color[1], led_color[2] * 0.5)  # Full brightness
            self.led.set_all(led_color)

        self.get_logger().info(f"Node computed graph value {lambda2:.3f} in round {self.round_counter}.\n")

    def destroy_node(self):
        super().destroy_node()
        self.led.exit()


def main(args=None):
    rclpy.init(args=args)

    gnn_node = MyNode()

    executor = MultiThreadedExecutor()
    executor.add_node(gnn_node)

    try:
        executor.spin()
    except KeyboardInterrupt:
        gnn_node.get_logger().info("KeyboardInterrupt received. Shutting down...")
    finally:
        # Destroy the node explicitly
        gnn_node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()